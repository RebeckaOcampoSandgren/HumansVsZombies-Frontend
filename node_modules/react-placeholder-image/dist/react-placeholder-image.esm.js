import { createElement, useState, useLayoutEffect } from 'react';
import url from 'url';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Removes any properties that undefined
 * @param obj - any object
 */
function removeUndefined(obj) {
  return Object.entries(obj).reduce(function (acc, _ref) {
    var key = _ref[0],
        value = _ref[1];

    if (value !== undefined) {
      acc[key] = value;
    }

    return acc;
  }, {});
}
/**
 * An id that can be appended to a URL in order to identify a particular image within a browser cache
 *
 * Many random-image-generating services will return different images for the same URL,
 * but the browser will cache the result for the first request and will serve the cached response for subsequent requests
 * which means that all requests will effectively return the _same_ image every time.
 * So, we circumvent the browser's caching by appending a unique id to each request which ensures a cache-miss
 */

function generateCacheId() {
  return (Math.random() * 100000).toFixed(0);
}

/**
 * Checks whether the input string is valid hex and then removes the hash
 * @param {string} hex
 */

function sanitizeHex(hex) {
  if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
    throw new Error("Expected valid hex color, got \"" + hex + "\"");
  }

  return hex.substring(1); // remove the hash
}
/**
 * Generates a URL for a custom placeholder image
 *
 * @param {number} width
 * @param {number} height
 * @param {object} [options]
 * @param {string} [options.backgroundColor={a light gray}]
 * @param {string} [options.text={the size of the image e.g. "200x100"}]
 * @param {string} [options.textColor={auto-contrast with backgroundColor}]
 */


function generateCustomPlaceholderURL(width, height, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      backgroundColor = _options.backgroundColor,
      textColor = _options.textColor,
      text = _options.text;
  return url.format({
    protocol: 'https',
    host: 'via.placeholder.com',
    pathname: [width + "x" + height, backgroundColor ? sanitizeHex(backgroundColor) : '', textColor ? sanitizeHex(textColor) : undefined].filter(function (part) {
      return part !== undefined;
    }).join('/'),
    query: removeUndefined({
      text: text
    })
  });
}
var CustomPlaceholder = function CustomPlaceholder(props) {
  var width = props.width,
      height = props.height,
      backgroundColor = props.backgroundColor,
      textColor = props.textColor,
      text = props.text,
      src = props.src,
      htmlProps = _objectWithoutPropertiesLoose(props, ["width", "height", "backgroundColor", "textColor", "text", "src"]);

  if (src !== undefined) {
    console.warn('Do not define the `src` prop for <CustomPlaceholder />; the src will be generated');
  }

  return createElement('img', _extends({
    src: generateCustomPlaceholderURL(width, height, {
      backgroundColor: backgroundColor,
      textColor: textColor,
      text: text
    }),
    alt: 'placeholder'
  }, htmlProps));
};

/**
 * Generates a URL for a random placeholder photo
 *
 * @param {number} width
 * @param {number} height
 * @param {object} [options]
 * @param {string} [options.grayscale={boolean}]
 */

function generatePhotoPlaceholderURL(width, height, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$grayscale = _options.grayscale,
      grayscale = _options$grayscale === void 0 ? false : _options$grayscale;
  return url.format({
    protocol: 'https',
    host: 'picsum.photos',
    pathname: "/" + width + "/" + height,
    query: removeUndefined({
      // if grayscale query param is present, the image will be grayscale, even if it is grayscale=false or grayscale=<nothing>
      // so we completely omit the key if grayscale is not true
      grayscale: grayscale ? grayscale : undefined,
      // automatically cache-bust the url so that same-size images on the page don't get the same image
      cacheId: generateCacheId()
    })
  });
}
var PhotoPlaceholder = function PhotoPlaceholder(props) {
  var width = props.width,
      height = props.height,
      grayscale = props.grayscale,
      src = props.src,
      htmlProps = _objectWithoutPropertiesLoose(props, ["width", "height", "grayscale", "src"]);

  if (src !== undefined) {
    console.warn('Do not define the `src` prop for <PhotoPlaceholder />; the src will be generated');
  }

  var _React$useState = useState(undefined),
      url = _React$useState[0],
      setURL = _React$useState[1]; // generating the URL is side-effectful because it generates a new random cache-busting query param
  // we use layout effect so that the url is calculated before the element is flushed to the DOM


  useLayoutEffect(function () {
    setURL(generatePhotoPlaceholderURL(width, height, {
      grayscale: grayscale
    }));
  }, [width, height, grayscale]);
  return createElement('img', _extends({
    src: url,
    alt: 'Placeholder'
  }, htmlProps));
};

export { CustomPlaceholder, PhotoPlaceholder, generateCustomPlaceholderURL, generatePhotoPlaceholderURL };
//# sourceMappingURL=react-placeholder-image.esm.js.map
